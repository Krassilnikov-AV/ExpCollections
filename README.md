# ExpCollections
Коллекции

1. Массив. Массивы встроены в язык и довольно производительны; они часто служат основой других коллекций.

2. Интерфейс Collection<T> является базовым интерфейсом для линейных коллекций. Он предоставляет основные операции, общие для всех коллекций.

Данный интерфейс предоставляет следующие методы: add(), addAll(), clear(), contains(), containsAll(), equals(), hashCode(), isEmpty(), iterator(), remove(), removeAll(), size(), toArray().
Абстрактный класс AbstractCollection реализует большинство методов этого интерфейса.
Интерфейс List<T> является одним из наиболее часто используемых интерфейсов коллекций, который обозначает упорядоченную коллекцию. Каждый элемент списка имеет целочисленный индекс; возможно добавление и удаление элементов по индексу. Дополнительно этот интерфейс предоставляет специальный итератор ListIterator<T>, который позволяет перемещаться по списку в обе стороны и вставлять новые элементы.

Данный интерфейс предоставляет следующие методы: get(), indexOf(), lastIndexOf(), listIterator(), set(), subList().
Абстрактный класс AbstractList наследуется от AbstractCollection и реализует большинство методов List интерфейса.
Абстрактный класс AbstractSequentialList наследуется от AbstractList и реализует большинство методов List интерфейса с упором на последовательный, чем на случайный доступ к элементам.
Реализация ArrayList<T> используется чаще всего в интерфейсе List. По сути является реализацией списка на основе массива. Кроме того, ArrayList очень эффективно использует память, и операции, основанные на доступе по индексу (сортировка, перемешивание, бинарный поиск и т.д.), выполняются быстро.

Данная реализация предоставляет следующие методы: ensureCapacity(), removeRange(), trimToSize(), clone().
Реализация LinkedList<T> используется гораздо реже. Является реализацией списка на основе двусвязного списка. LinkedList эффективнее при вставке/удалении элементов в начале или конце и при вставке/удалении в середине после итерации до нужного места. Также LinkedList потребляет значительно больше памяти, чем ArrayList.

Данная реализация предоставляет следующие методы: addFirst(), addLast(), clone(), getFirst(), getLast(), removeFirst(), removeLast().
3. Интерфейс Set<T> предоставляет абстракцию математического множества, т.е. неупорядоченную коллекцию, не содержащую одинаковых элементов. Из-за неупорядоченности элементы множества нельзя получить по их индексу, поэтому для множеств не имеет смысла сортировка и перемешивание элементов. Однако при этом операции проверки на наличие элемента во множестве эффективнее, чем в списке.

Данный интерфейс предоставляет следующие методы: isEmpty().
Абстрактный класс AbstractSet наследуется от AbstractCollection и реализует большинство методов Set интерфейса.
Интерфейс SortedSet<T> является расширением Set<T>. Он предполагает наличие отношения порядка на своих элементах. Из-за этого SortedSet предоставляет дополнительные операции.

Данный интерфейс предоставляет следующие методы: clone(), comparator(), first(), headSet(), last(), subSet(), tailSet().
Реализация HashSet<T> — это наиболее часто используемая реализация множества, потому что основные задачи множества она выполняет наиболее эффективно. HashSet основан на HashMap. Поэтому, в частности, для использования HashSet необходима правильная реализация методов equals() и hashCode().

Данная реализация наследуется от AbstractSet.
Данная реализация предоставляет следующие методы: clone().
Реализация LinkedHashSet<T> объединяет множество на основе хеш-таблицы и связный список. Эффективность всех операций на нём та же, что и у HashSet, но порядок итерации по нему не псевдослучаен, а соответствует порядку добавления элементов в это множество. LinkedHashSet основан на LinkedHashMap и наследует HashSet, поэтому для него также справедливы условия на методы equals() и hashCode() у элементов.

Данная реализация наследуется от HashSet.
Реализация TreeSet<T> — это множество, основанное на TreeMap. Оно реализует интерфейс SortedSet<T>, и в нём могут храниться только элементы, на которых задано отношение порядка. Класс TreeSet основан на TreeMap, и поэтому все операции над элементами имеют логарифмическую сложность. Это хуже, чем у HashSet, поэтому TreeSet используется только тогда, когда необходимо так или иначе сортировать элементы множества.

Данная реализация наследуется от AbstractSet.
Данная реализация предоставляет следующие методы: clone(), comparator(), first(), last(), headSet(), subSet(), tailSet().
Интерфейс Queue<T> представляет собой контейнер, в который можно добавлять элементы и доставать их оттуда. Релизации Queue<T> могут ограничивать максимальное количество элементов в коллекции. Поэтому Queue<T> предоставляет два набора методов для указанных операций. Первый набор в граничных ситуациях выбрасывает исключение, а второй — возвращает специальное значение (null или boolean).

Абстрактный класс AbstractQueue наследуется от AbstractCollection и реализует большинство методов Queue интерфейса.
Данный интерфейс предоставляет следующие методы: offer(), peek(), poll().
Интерфейс Deque<T> обозначает дек, структуру данных, являющуюся одновременно стеком и очередью. В дек можно добавлять и удалять элементы с двух сторон.

Данный интерфейс предоставляет следующие методы: offer(), peek(), poll(), addFirst(), addLast(), descendingIterator(), element(), getFirst(), getLast(), offerFirst(), offerLast(), peekFirst(), peekLast(), pollFirst(), pollLast(), pop(), push(), removeFirst(), removeFirstOccurrence(), removeLast(), removeLastOccurrence(), size().
Реализация ArrayDeque<T> с помощью массива - наиболее удобная и эффективная.

Данная реализация наследуется от AbstractCollection и реализует интерфейс Deque.
Данный интерфейс предоставляет следующие методы: isEmpty(), clone(), toArray().
java.util.Arrays предоставляет статические методы для манипуляций с массивами, такие как: binarySearch(), equals(), fill(), sort().

java.util.Collections предоставляет статические методы для манипуляций с массивами, такие как: binarySearch(), fill(), sort(), copy(), enumeration(), indexOfSubList(), lastIndexOfSubList(), list(), max(), min(), nCopies(), replaceAll(), reverse(), reverseOrder(), rotate(), shuffle(), singleton(), singletonList(), singletonMap(), swap(), synchronizedCollection(), synchronizedList(), synchronizedMap(), synchronizedSet(), synchronizedSortedMap(), synchronizedSortedSet(), unmodifiableCollection(), unmodifiableList(), unmodifiableMap(), unmodifiableSet(), unmodifiableSortedMap(), unmodifiableSortedSet().

Иерархия коллекций
Иерархия коллекций
