# Коллекции

1. **Массив**. Массивы встроены в язык и довольно производительны; они часто служат основой других коллекций.

2. **Интерфейс `Collection<T>`** является базовым интерфейсом для линейных коллекций. Он предоставляет основные операции, общие для всех коллекций.
    - Данный интерфейс предоставляет следующие методы: `add()`, `addAll()`, `clear()`, `contains()`, `containsAll()`, `equals()`, `hashCode()`, `isEmpty()`, `iterator()`, `remove()`, `removeAll()`, `size()`, `toArray()`.
    - Абстрактный класс `AbstractCollection` реализует большинство методов этого интерфейса.

3. **Интерфейс `List<T>`** является одним из наиболее часто используемых интерфейсов коллекций, который обозначает упорядоченную коллекцию. Каждый элемент списка имеет целочисленный индекс; возможно добавление и удаление элементов по индексу. Дополнительно этот интерфейс предоставляет специальный итератор `ListIterator<T>`, который позволяет перемещаться по списку в обе стороны и вставлять новые элементы.
    - Данный интерфейс предоставляет следующие методы: `get()`, `indexOf()`, `lastIndexOf()`, `listIterator()`, `set()`, `subList()`.
    - Абстрактный класс `AbstractList` наследуется от `AbstractCollection` и реализует большинство методов `List` интерфейса.
    - Абстрактный класс `AbstractSequentialList ` наследуется от `AbstractList` и реализует большинство методов `List` интерфейса с упором на последовательный, чем на случайный доступ к элементам.

4. **Реализация `ArrayList<T>`** используется чаще всего в интерфейсе `List`. По сути является реализацией списка на основе массива. Кроме того, `ArrayList` очень эффективно использует память, и операции, основанные на доступе по индексу (сортировка, перемешивание, бинарный поиск и т.д.), выполняются быстро.
    - Данная реализация предоставляет следующие методы: `ensureCapacity()`, `removeRange()`, `trimToSize()`, `clone()`.

5. **Реализация `LinkedList<T>`** используется гораздо реже. Является реализацией списка на основе двусвязного списка. `LinkedList` эффективнее при вставке/удалении элементов в начале или конце и при вставке/удалении в середине после итерации до нужного места. Также `LinkedList` потребляет значительно больше памяти, чем `ArrayList`.
    - Данная реализация предоставляет следующие методы: `addFirst()`, `addLast()`, `clone()`, `getFirst()`, `getLast()`, ` removeFirst()`, `removeLast()`.

6. **Интерфейс `Set<T>`** предоставляет абстракцию математического множества, т.е. неупорядоченную коллекцию, не содержащую одинаковых элементов. Из-за неупорядоченности элементы множества нельзя получить по их индексу, поэтому для множеств не имеет смысла сортировка и перемешивание элементов. Однако при этом операции проверки на наличие элемента во множестве эффективнее, чем в списке.
    - Данный интерфейс предоставляет следующие методы: `isEmpty()`.
    - Абстрактный класс `AbstractSet` наследуется от `AbstractCollection` и реализует большинство методов `Set` интерфейса.

7. **Интерфейс `SortedSet<T>`** является расширением `Set<T>`. Он предполагает наличие отношения порядка на своих элементах. Из-за этого `SortedSet` предоставляет дополнительные операции.
    - Данный интерфейс предоставляет следующие методы: `clone()`, `comparator()`, `first()`, `headSet()`, `last()`, `subSet()`, `tailSet()`.

8. **Реализация `HashSet<T>`** — это наиболее часто используемая реализация множества, потому что основные задачи множества она выполняет наиболее эффективно. HashSet основан на `HashMap`. Поэтому, в частности, для использования `HashSet` необходима правильная реализация методов `equals()` и `hashCode()`.
    - Данная реализация наследуется от `AbstractSet`.
    - Данная реализация предоставляет следующие методы: `clone()`.

9. **Реализация `LinkedHashSet<T>`** объединяет множество на основе хеш-таблицы и связный список. Эффективность всех операций на нём та же, что и у `HashSet`, но порядок итерации по нему не псевдослучаен, а соответствует порядку добавления элементов в это множество. `LinkedHashSet` основан на `LinkedHashMap` и наследует `HashSet`, поэтому для него также справедливы условия на методы `equals()` и `hashCode()` у элементов.
    - Данная реализация наследуется от `HashSet`.

10. **Реализация `TreeSet<T>`** — это множество, основанное на `TreeMap`. Оно реализует интерфейс `SortedSet<T>`, и в нём могут храниться только элементы, на которых задано отношение порядка. Класс `TreeSet` основан на `TreeMap`, и поэтому все операции над элементами имеют логарифмическую сложность. Это хуже, чем у `HashSet`, поэтому TreeSet используется только тогда, когда необходимо так или иначе сортировать элементы множества.
    - Данная реализация наследуется от `AbstractSet`.
    - Данная реализация предоставляет следующие методы: `clone()`, `comparator()`, `first()`, `last()`, `headSet()`, `subSet()`, `tailSet()`.

11. **Интерфейс `Queue<T>`** представляет собой контейнер, в который можно добавлять элементы и доставать их оттуда. Релизации `Queue<T>` могут ограничивать максимальное количество элементов в коллекции. Поэтому `Queue<T>` предоставляет два набора методов для указанных операций. Первый набор в граничных ситуациях выбрасывает исключение, а второй — возвращает специальное значение (null или boolean).
    - Абстрактный класс `AbstractQueue` наследуется от `AbstractCollection` и реализует большинство методов `Queue` интерфейса.
    - Данный интерфейс предоставляет следующие методы: `offer()`, `peek()`, `poll()`.

12. **Интерфейс `Deque<T>`** обозначает дек, структуру данных, являющуюся одновременно стеком и очередью. В дек можно добавлять и удалять элементы с двух сторон.
    - Данный интерфейс предоставляет следующие методы: `offer()`, `peek()`, `poll()`, `addFirst()`, `addLast()`, `descendingIterator()`, `element()`, `getFirst()`, `getLast()`, `offerFirst()`, `offerLast()`, `peekFirst()`, `peekLast()`, `pollFirst()`, `pollLast()`, `pop()`, `push()`, `removeFirst()`, `removeFirstOccurrence()`, `removeLast()`, `removeLastOccurrence()`, `size()`.

13. **Реализация `ArrayDeque<T>`** с помощью массива - наиболее удобная и эффективная.
    - Данная реализация наследуется от `AbstractCollection` и реализует интерфейс `Deque`.
    - Данный интерфейс предоставляет следующие методы: `isEmpty()`, `clone()`, `toArray()`.

14. **`java.util.Arrays`** предоставляет статические методы для манипуляций с массивами, такие как: `binarySearch()`, `equals()`, `fill()`, `sort()`.

15. **`java.util.Collections`** предоставляет статические методы для манипуляций с массивами, такие как: `binarySearch()`, `fill()`, `sort()`, `copy()`, `enumeration()`, `indexOfSubList()`, `lastIndexOfSubList()`, `list()`, `max()`, `min()`, `nCopies()`, `replaceAll()`, `reverse()`, `reverseOrder()`, `rotate()`, `shuffle()`, `singleton()`, `singletonList()`, `singletonMap()`, `swap()`, `synchronizedCollection()`, `synchronizedList()`, `synchronizedMap()`, `synchronizedSet()`, `synchronizedSortedMap()`, ` synchronizedSortedSet()`, `unmodifiableCollection()`, `unmodifiableList()`, `unmodifiableMap()`, `unmodifiableSet()`, `unmodifiableSortedMap()`, `unmodifiableSortedSet()`.

16. Иерархия коллекций  
    ![Иерархия коллекций](https://i.gyazo.com/c728629e97972ba7d715d23c2f3e7b51.png)
    
